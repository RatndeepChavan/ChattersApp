import mongoose from "mongoose";
import User from "#src/models/UserModel";
import { SuccessResponse } from "#src/utils/responses/SuccessResponse";
import { ErrorResponse } from "#src/utils/responses/ErrorResponse";

/**
 * @memberof controllers.UserControllers
 *
 * @function getSearchedUsers
 *
 * @description
 * * <b>`POST REQUEST`</b>
 * - Retrieves users based on search username,
 * - Exclude current user and users who already have initiated the conversation.
 *
 * @param {Request} req request sent from client with `userId` populated by middleware.
 * @param {Response} res response generated from server
 *
 * @returns {Response} JSON response with success or error message.
 * <b>HTTP response codes</b>
 * - 500 : `Internal server error`
 * - 200 : `Ok`
 */
export const getSearchedUsers = async (req, res) => {
	try {
		const { text } = req.body;
		const currentUserId = new mongoose.Types.ObjectId(`${req.userId}`);

		// Aggregation pipeline to search for users and check for existing conversations
		const data = await User.aggregate([
			{
				$match: {
					// exclude current user
					_id: { $ne: currentUserId },

					// Match users with usernames
					username: { $regex: `.*${text}.*`, $options: "i" },
				},
			},
			{
				// Lookup to find any conversations involving the current user and each matched user
				$lookup: {
					from: "conversations",
					let: { userId: "$_id" },
					pipeline: [
						{
							$match: {
								$expr: {
									$and: [
										{ $in: [currentUserId, ["$initiator", "$target"]] },
										{ $in: ["$$userId", ["$initiator", "$target"]] },
									],
								},
							},
						},
					],
					// Filed generated by lookup
					as: "existingConversations",
				},
			},
			{
				// Exclude already initiated conversations
				$match: {
					"existingConversations.status": { $nin: ["PENDING", "ACCEPTED", "BLOCKED"] },
				},
			},
			{
				// Project required field
				$project: {
					username: 1,
					status: 1,
					image: 1,
				},
			},
		]);

		// Send successful response with data
		return new SuccessResponse(res).send({ data });
	} catch (error) {
		// Logging the error details
		logger.error(error);

		// Send error response
		return new ErrorResponse(res).send();
	}
};
